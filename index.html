<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Frame Rate Detector</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #2c3e50;
        }
        
        .instructions {
            background-color: #fff;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .drop-zone {
            border: 3px dashed #3498db;
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            background-color: #ecf0f1;
            transition: all 0.3s;
            margin-bottom: 20px;
            cursor: pointer;
        }
        
        .drop-zone.dragover {
            background-color: #d6eaf8;
            border-color: #2980b9;
        }
        
        .drop-zone p {
            margin-bottom: 15px;
            font-size: 18px;
            color: #7f8c8d;
        }
        
        .file-btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        .file-btn:hover {
            background-color: #2980b9;
        }
        
        .hidden {
            display: none;
        }
        
        .progress {
            background-color: #fff;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        
        .progress-bar {
            height: 20px;
            background-color: #ecf0f1;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background-color: #3498db;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .result {
            background-color: #fff;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        
        .fps-display {
            font-size: 48px;
            font-weight: bold;
            color: #2c3e50;
            margin: 20px 0;
        }
        
        .error {
            background-color: #fff;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border-left: 5px solid #e74c3c;
        }
        
        .analysis-details {
            background-color: #f9f9f9;
            border-radius: 4px;
            padding: 15px;
            margin-top: 20px;
            font-size: 14px;
            text-align: left;
        }
        
        .note {
            font-style: italic;
            color: #7f8c8d;
            margin-top: 15px;
            font-size: 14px;
        }
        
        @media (max-width: 600px) {
            .container {
                padding: 10px;
            }
            
            .drop-zone {
                padding: 20px 10px;
            }
            
            .fps-display {
                font-size: 36px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Video Frame Rate Detector</h1>
        <div class="instructions">
            <p>Drag and drop a video file below to detect its true frame rate (FPS).</p>
            <p>Analysis is performed entirely in your browser - no data is uploaded.</p>
        </div>
        
        <div id="dropZone" class="drop-zone">
            <p>Drop your video file here</p>
            <p>or</p>
            <label for="fileInput" class="file-btn">Select Video File</label>
            <input type="file" id="fileInput" accept="video/*" style="display:none">
        </div>
        
        <div id="progress" class="progress hidden">
            <h2>Analyzing video...</h2>
            <div class="progress-bar">
                <div id="progressFill" class="progress-fill"></div>
            </div>
            <p><span id="progressPercent">0</span>% complete</p>
        </div>
        
        <div id="error" class="error hidden">
            <h2>Error</h2>
            <p id="errorText"></p>
        </div>
        
        <div id="result" class="result hidden">
            <h2>Results:</h2>
            <div class="fps-display">
                <span id="fpsValue">--</span> FPS
            </div>
            <div id="analysisDetails" class="analysis-details"></div>
        </div>
    </div>
    
    <script>
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const progressDiv = document.getElementById('progress');
        const progressFill = document.getElementById('progressFill');
        const progressPercent = document.getElementById('progressPercent');
        const resultDiv = document.getElementById('result');
        const fpsValue = document.getElementById('fpsValue');
        const analysisDetails = document.getElementById('analysisDetails');
        const errorDiv = document.getElementById('error');
        const errorText = document.getElementById('errorText');
        
        // Handle file drops and uploads
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });
        
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            
            if (e.dataTransfer.files.length) {
                processFile(e.dataTransfer.files[0]);
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length) {
                processFile(e.target.files[0]);
            }
        });
        
        dropZone.addEventListener('click', () => {
            fileInput.click();
        });
        
        function processFile(file) {
            // Check if it's a video file
            if (!file.type.startsWith('video/')) {
                showError('Please select a valid video file.');
                return;
            }
            
            // Hide previous results and errors
            resultDiv.classList.add('hidden');
            errorDiv.classList.add('hidden');
            
            // Create a URL for the video file
            const videoUrl = URL.createObjectURL(file);
            
            // Detect the frame rate
            detectFrameRate(videoUrl, file.name);
        }
        
        function detectFrameRate(videoUrl, fileName) {
            // Create video element for analysis
            const video = document.createElement('video');
            video.preload = 'auto';
            video.muted = true;
            video.src = videoUrl;
            
            // Create canvas for frame analysis
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            canvas.width = 32;  // Small size for performance
            canvas.height = 32;
            
            // Show progress
            progressDiv.classList.remove('hidden');
            progressPercent.textContent = '0';
            progressFill.style.width = '0%';
            
            video.onloadedmetadata = function() {
                analyzeVideo();
            };
            
            video.onerror = function() {
                URL.revokeObjectURL(videoUrl);
                showError('Error loading video. The format may not be supported by your browser.');
            };
            
            // Binary search approach for faster convergence
            function analyzeVideo() {
                // Get length of video in seconds
                const duration = video.duration;
                const testSegments = Math.min(8, Math.floor(duration));
                
                if (testSegments < 1) {
                    showError("Video too short to analyze");
                    return;
                }
                
                // Pick test segments spread throughout the video
                const segmentTimes = [];
                for (let i = 0; i < testSegments; i++) {
                    segmentTimes.push(i * Math.floor(duration / testSegments));
                }
                
                let segmentIndex = 0;
                const results = [];
                
                analyzeNextSegment();
                
                function analyzeNextSegment() {
                    if (segmentIndex >= segmentTimes.length) {
                        // All segments analyzed
                        calculateFinalResult(results);
                        return;
                    }
                    
                    // Update progress
                    const progress = Math.round((segmentIndex / segmentTimes.length) * 100);
                    progressPercent.textContent = progress;
                    progressFill.style.width = `${progress}%`;
                    
                    const startTime = segmentTimes[segmentIndex];
                    
                    // Binary search for frame times
                    binarySearchFrames(startTime, startTime + 1, (framesInSegment) => {
                        results.push(framesInSegment);
                        segmentIndex++;
                        analyzeNextSegment();
                    });
                }
            }
            
            function binarySearchFrames(startTime, endTime, callback) {
                // First, check for frame boundaries at various resolutions
                // Start with coarse resolution, then refine
                const initialSampleCount = 30; // Initial coarse sampling
                
                // First pass: coarse sampling to get approximate frame boundaries
                findFramesAtResolution(startTime, endTime, initialSampleCount, (coarseFrames) => {
                    if (coarseFrames.length <= 1) {
                        // Try again with higher resolution if we found too few frames
                        findFramesAtResolution(startTime, endTime, 60, callback);
                        return;
                    }
                    
                    // Get approximate frame interval from coarse sampling
                    let totalInterval = 0;
                    for (let i = 1; i < coarseFrames.length; i++) {
                        totalInterval += coarseFrames[i] - coarseFrames[i-1];
                    }
                    const avgInterval = totalInterval / (coarseFrames.length - 1);
                    const estFrameRate = 1 / avgInterval;
                    
                    // Second pass: targeted sampling around estimated frame times
                    // This dramatically reduces the number of samples needed
                    const refinedSamples = refineSampling(startTime, endTime, estFrameRate);
                    findFramesAtTargetedTimes(refinedSamples, (refinedFrames) => {
                        callback(refinedFrames.length);
                    });
                });
            }
            
            function refineSampling(startTime, endTime, estFPS) {
                // Generate samples around expected frame boundaries
                // This is much more efficient than uniform sampling
                const samples = [];
                const estInterval = 1 / estFPS;
                
                // Calculate expected frame boundaries
                let frameTime = startTime;
                while (frameTime < endTime) {
                    // Sample at expected frame time and slightly before/after
                    // to account for timing inaccuracies
                    const delta = estInterval / 10; // 10% of interval
                    samples.push(frameTime - delta);
                    samples.push(frameTime);
                    samples.push(frameTime + delta);
                    
                    frameTime += estInterval;
                }
                
                return samples.filter(t => t >= startTime && t <= endTime);
            }
            
            function findFramesAtResolution(startTime, endTime, sampleCount, callback) {
                const interval = (endTime - startTime) / sampleCount;
                const sampleTimes = [];
                
                for (let i = 0; i <= sampleCount; i++) {
                    sampleTimes.push(startTime + (i * interval));
                }
                
                findFramesAtTargetedTimes(sampleTimes, callback);
            }
            
            function findFramesAtTargetedTimes(times, callback) {
                let lastHash = null;
                const frameTimes = [];
                let timeIndex = 0;
                
                processNextTime();
                
                function processNextTime() {
                    if (timeIndex >= times.length) {
                        callback(frameTimes);
                        return;
                    }
                    
                    video.currentTime = times[timeIndex];
                    
                    video.onseeked = function() {
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        const hash = computePerceptualHash(ctx);
                        
                        if (lastHash === null || !areHashesSimilar(hash, lastHash)) {
                            frameTimes.push(video.currentTime);
                            lastHash = hash;
                        }
                        
                        timeIndex++;
                        processNextTime();
                    };
                }
            }
            
            function computePerceptualHash(ctx) {
                // dHash algorithm - much more robust than pixel sampling
                const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
                const grayValues = [];
                
                // Convert to grayscale
                for (let i = 0; i < imgData.length; i += 4) {
                    const gray = Math.round(0.299 * imgData[i] + 0.587 * imgData[i+1] + 0.114 * imgData[i+2]);
                    grayValues.push(gray);
                }
                
                // Downsample to 8x8 for hash calculation
                const downsample = [];
                const blockSize = canvas.width / 8;
                
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        let sum = 0, count = 0;
                        for (let dy = 0; dy < blockSize; dy++) {
                            for (let dx = 0; dx < blockSize; dx++) {
                                const idx = ((y * blockSize + dy) * canvas.width + (x * blockSize + dx));
                                if (idx < grayValues.length) {
                                    sum += grayValues[idx];
                                    count++;
                                }
                            }
                        }
                        downsample.push(Math.round(sum / count));
                    }
                }
                
                // Compute dHash: compare adjacent pixels
                const hash = [];
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 7; x++) {
                        const idx = y * 8 + x;
                        hash.push(downsample[idx] > downsample[idx + 1] ? 1 : 0);
                    }
                }
                
                return hash;
            }
            
            function areHashesSimilar(hash1, hash2) {
                // Count bit differences (Hamming distance)
                let diffCount = 0;
                for (let i = 0; i < hash1.length; i++) {
                    if (hash1[i] !== hash2[i]) {
                        diffCount++;
                    }
                }
                // Threshold for similarity - dHash is very sensitive to frame changes
                return diffCount < 10;
            }
            
            function calculateFinalResult(frameCountResults) {
                if (frameCountResults.length === 0) {
                    displayResults(30, fileName, "Analysis failed. Using default value.");
                    return;
                }
                
                // Remove outliers (more than 2 standard deviations from mean)
                const mean = frameCountResults.reduce((sum, val) => sum + val, 0) / frameCountResults.length;
                const squareDiffs = frameCountResults.map(val => (val - mean) ** 2);
                const stdDev = Math.sqrt(squareDiffs.reduce((sum, val) => sum + val, 0) / frameCountResults.length);
                
                const validResults = frameCountResults.filter(val => Math.abs(val - mean) <= 2 * stdDev);
                const avgFPS = validResults.reduce((sum, val) => sum + val, 0) / validResults.length;
                
                // Match to standard frame rates
                const matchedFPS = findNearestStandardFPS(avgFPS);
                
                // Generate detailed analysis text
                const details = `
                    Analyzed ${frameCountResults.length} segments with binary search method.
                    Raw calculation: ${avgFPS.toFixed(2)} FPS.
                    Standard deviation: ${stdDev.toFixed(2)} frames.
                    Per-segment results: [${frameCountResults.join(', ')}]
                `;
                
                displayResults(matchedFPS, fileName, details);
                URL.revokeObjectURL(video.src);
            }
        }
        
        function findNearestStandardFPS(fps) {
            // Common standard frame rates
            const standardRates = [
                23.976, 24, 25, 29.97, 30, 
                48, 50, 59.94, 60, 
                120, 144, 240
            ];
            
            // If we're within 1% of a standard rate, use that rate
            for (const rate of standardRates) {
                const percentDiff = Math.abs(fps - rate) / rate;
                if (percentDiff < 0.01) {
                    return rate;
                }
            }
            
            // Check for common rational multiples/divisors of standard rates
            // (like 15fps which is 1/2 of 30fps, or 120fps which is 2x 60fps)
            const commonMultipleDivisors = [2, 3, 4];
            
            for (const rate of standardRates) {
                for (const factor of commonMultipleDivisors) {
                    // Check if it's a divisor (e.g., 15fps from 30fps)
                    const divisor = rate / factor;
                    const percentDiffDivisor = Math.abs(fps - divisor) / divisor;
                    if (percentDiffDivisor < 0.03) {
                        return Math.round(divisor * 1000) / 1000;
                    }
                    
                    // Check if it's a multiple (e.g., 120fps from 60fps)
                    const multiple = rate * factor;
                    const percentDiffMultiple = Math.abs(fps - multiple) / multiple;
                    if (percentDiffMultiple < 0.03) {
                        return Math.round(multiple * 1000) / 1000;
                    }
                }
            }
            
            // Otherwise round to 3 decimal places
            return Math.round(fps * 1000) / 1000;
        }
        
        function showError(message) {
            errorDiv.classList.remove('hidden');
            errorText.textContent = message;
            progressDiv.classList.add('hidden');
        }
        
        function displayResults(fps, fileName, details) {
            // Hide progress, show results
            progressDiv.classList.add('hidden');
            resultDiv.classList.remove('hidden');
            
            // Display the FPS
            fpsValue.textContent = fps;
            
            // Display analysis details
            analysisDetails.innerHTML = `
                <p>File analyzed: ${fileName}</p>
                <p>${details}</p>
                <p class="note">Note: Results are based on advanced binary search and perceptual hashing techniques.</p>
            `;
        }
    </script>
</body>
</html>
